<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertex AI Quiz - Agentverse Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a1a;
            color: #e0e0e0;
        }
        h1, h2, h3 {
            font-family: 'Orbitron', sans-serif;
        }
        .glow-text {
            text-shadow: 0 0 8px rgba(100, 200, 255, 0.7), 0 0 12px rgba(100, 200, 255, 0.5);
        }
        .quiz-container {
            background-color: rgba(20, 20, 40, 0.6);
            border: 1px solid rgba(100, 200, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .btn {
            transition: all 0.3s ease;
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .btn-primary:hover {
            background-color: #60a5fa;
        }
        .option-btn {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        .option-btn:hover {
            background-color: rgba(100, 200, 255, 0.2);
        }
        .option-btn.correct {
            background-color: #16a34a; /* green-600 */
            border-color: #4ade80; /* green-400 */
        }
        .option-btn.incorrect {
            background-color: #dc2626; /* red-600 */
            border-color: #f87171; /* red-400 */
        }
        .rationale {
            background-color: rgba(0,0,0,0.2);
            border-left: 3px solid #93c5fd;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Header Section -->
    <header class="text-center py-12">
        <div class="container mx-auto px-6">
            <h1 class="text-4xl md:text-5xl font-bold text-white glow-text">Agentverse Challenge</h1>
            <p class="text-lg md:text-xl text-blue-300 mt-4">Test Your Knowledge of Vertex AI & Gemini</p>
        </div>
    </header>

    <!-- Quiz Main Content -->
    <main class="container mx-auto px-6 py-8">
        <div id="quiz-container" class="quiz-container rounded-xl p-6 md:p-10 max-w-4xl mx-auto">
            <!-- Start Screen -->
            <div id="start-screen">
                <h2 class="text-3xl font-bold text-blue-300 mb-4">Welcome, Builder!</h2>
                <p class="mb-8 text-gray-300">You are about to face 10 challenges drawn from the Agentverse Chronicles. Your knowledge of the guilds, the Gemini arsenal, and the fortified realm of Vertex AI will be tested. Prove your mastery.</p>
                <button id="start-btn" class="btn btn-primary font-bold py-3 px-6 rounded-lg text-lg">Begin the Challenge</button>
            </div>

            <!-- Question Screen -->
            <div id="question-screen" class="hidden">
                <div class="mb-6">
                    <p id="progress-text" class="text-sm text-blue-400">Question 1 of 10</p>
                    <h2 id="question-text" class="text-2xl font-semibold text-white mt-2">Question text goes here...</h2>
                    <p id="hint-text" class="text-sm text-gray-400 italic mt-3"></p>
                </div>
                <div id="answer-buttons" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Options will be dynamically inserted here -->
                </div>
                <div id="rationale-container" class="mt-6 hidden"></div>
                <button id="next-btn" class="btn btn-primary font-bold py-2 px-6 rounded-lg mt-8 hidden">Next</button>
            </div>

            <!-- Results Screen -->
            <div id="results-screen" class="hidden text-center">
                <h2 class="text-3xl font-bold text-blue-300 mb-4">Challenge Complete!</h2>
                <p class="text-5xl font-bold glow-text mb-4" id="score-text">8 / 10</p>
                <p class="text-lg text-gray-300 mb-8" id="score-message">A formidable display of knowledge!</p>
                <div class="flex justify-center space-x-4">
                    <button id="restart-btn" class="btn btn-primary font-bold py-3 px-6 rounded-lg">Try Again</button>
                    <a href="index.html" class="btn bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg">Return to Chronicles</a>
                </div>
            </div>
        </div>
    </main>

    <script>
        const quizData = {
          "questions": [
            {
              "question": "According to the 'Agentverse Chronicles', what was the primary crisis that led to the creation of Vertex AI in 2021?",
              "hint": "Think about the gap between creating a successful model in a lab and making it useful in a real-world business setting.",
              "answerOptions": [
                { "text": "The difficulty in training models with more than one modality, like text and images together.", "isCorrect": false, "rationale": "While multimodal models are a key feature of the Gemini era, the initial problem Vertex AI aimed to solve was more about deployment and operations." },
                { "text": "The widespread problem of 'pilot purgatory,' where promising ML models failed to make it into production.", "isCorrect": true, "rationale": "This term directly addresses the challenge of moving models from experimental stages to scalable, reliable applications, which was the core mission of the platform's unification mandate." },
                { "text": "The lack of powerful foundation models available to developers.", "isCorrect": false, "rationale": "The rise of foundation models happened after Vertex AI's initial launch; the platform was first built to manage the lifecycle of more traditional, custom-trained models." },
                { "text": "The high cost of using Google Cloud's individual AI and ML services.", "isCorrect": false, "rationale": "While cost is always a factor, the main issue was the operational complexity and friction caused by the fragmentation of services, not just their individual prices." }
              ]
            },
            {
              "question": "Which Agentverse persona is most closely associated with building the 'MLOps fortress' using tools like Vertex AI Pipelines and Feature Store?",
              "hint": "Consider which role is responsible for the stability, reliability, and operational health of the entire system.",
              "answerOptions": [
                { "text": "The Scholar (Data Engineer)", "isCorrect": false, "rationale": "The Scholar focuses on sourcing and preparing data, primarily working within tools like BigQuery to provide the intelligence for agents." },
                { "text": "The Shadowblade (Developer)", "isCorrect": false, "rationale": "The Shadowblade crafts the specific application code and prompt logic, operating within environments like Colab Enterprise." },
                { "text": "The Summoner (Architect)", "isCorrect": false, "rationale": "The Summoner designs the high-level system of agents, focusing on orchestration and user experience, often using Agent Builder." },
                { "text": "The Guardian (DevOps / SRE)", "isCorrect": true, "rationale": "This persona's role is to build and protect the realm's infrastructure, making tools for automation, governance, and reliability their primary concern." }
              ]
            },
            {
              "question": "What was the game-changing feature introduced with Gemini 1.5 Pro that fundamentally altered the scale of problems an agent could address in a single prompt?",
              "hint": "This feature is analogous to giving an agent an entire library to read for every question it's asked.",
              "answerOptions": [
                { "text": "Native multimodality from the ground up.", "isCorrect": false, "rationale": "Native multimodality was the defining innovation of Gemini 1.0, allowing seamless reasoning across different data types." },
                { "text": "A breakthrough 1-2 million token context window.", "isCorrect": true, "rationale": "This massive context window allows the model to ingest and reason over vast amounts of information at once, such as entire codebases or books." },
                { "text": "The introduction of 'thinking' and adaptive reasoning.", "isCorrect": false, "rationale": "This capability, which involves reasoning before responding, is the key feature of the more recent Gemini 2.5 models." },
                { "text": "A suite of lightweight, open models for on-device tasks.", "isCorrect": false, "rationale": "Lightweight open models are characteristic of the Gemma family, designed for resource-constrained environments." }
              ]
            },
            {
              "question": "For a Scholar (Data Engineer) wanting to perform large-scale text summarization on customer reviews stored in BigQuery, what is the most direct and efficient method described?",
              "hint": "The most efficient path keeps the data and the computation in the same place, using the native language of that environment.",
              "answerOptions": [
                { "text": "Export the data to a CSV, then use the Vertex AI SDK in a Colab Enterprise notebook to process it.", "isCorrect": false, "rationale": "This approach involves unnecessary data movement and requires coding in Python, whereas a more integrated method exists." },
                { "text": "Use the `ML.GENERATE_TEXT` function directly within a BigQuery SQL query.", "isCorrect": true, "rationale": "This method allows the Scholar to invoke a Gemini model using SQL, applying the summarization task directly to the data where it resides." },
                { "text": "Build a custom application using the Vertex AI Agent Builder and connect it to the BigQuery data source.", "isCorrect": false, "rationale": "Agent Builder is better suited for creating conversational agents; for a large-scale, non-interactive data processing task, it's not the most direct tool." },
                { "text": "Fine-tune a Gemma model on the review data and then deploy it to an endpoint for batch processing.", "isCorrect": false, "rationale": "Fine-tuning is a much more involved process. For a standard task like summarization, a powerful foundation model can be used directly without this step." }
              ]
            },
            {
              "question": "What is the primary purpose of 'grounding' an agent, a core principle for the Summoner (Architect) using Vertex AI Agent Builder?",
              "hint": "Think about how to make an agent's answers more trustworthy and less like creative fiction.",
              "answerOptions": [
                { "text": "To reduce the latency of the model's responses.", "isCorrect": false, "rationale": "While performance is important, grounding is primarily concerned with the quality and accuracy of the information provided." },
                { "text": "To connect the agent to verifiable sources of truth, like enterprise data or Google Search, to reduce hallucinations.", "isCorrect": true, "rationale": "This process ensures the agent's responses are based on factual, up-to-date information, making them more accurate and reliable." },
                { "text": "To allow the agent to perform multi-step, complex reasoning before answering.", "isCorrect": false, "rationale": "Complex reasoning is an intrinsic capability of advanced models like Gemini 2.5, whereas grounding is about connecting any model to external facts." },
                { "text": "To enable the agent to interact with users across multiple modalities like images and audio.", "isCorrect": false, "rationale": "Multimodality is a feature of the underlying model (e.g., Gemini), not the process of grounding itself." }
              ]
            },
            {
              "question": "Which of the following is an example of a 'Shadowblade' (Developer) workflow on Vertex AI?",
              "hint": "The Shadowblade is the artisan of code. Their workflow involves crafting the specific logic of the application.",
              "answerOptions": [
                { "text": "Using a no-code interface to design a customer service chatbot's conversation flow.", "isCorrect": false, "rationale": "This describes the work of a Summoner using a tool like Agent Builder to orchestrate the overall agentic system." },
                { "text": "Writing a SQL query in BigQuery to generate vector embeddings for a product catalog.", "isCorrect": false, "rationale": "This is a classic task for a Scholar, working directly with data at scale within the data warehouse." },
                { "text": "Using the Vertex AI SDK for Python in a Colab Enterprise notebook to design and test specific prompts for a GenAI application.", "isCorrect": true, "rationale": "This workflow involves writing code to interact with the model via an SDK in a secure development environment, which is the core craft of the Shadowblade." },
                { "text": "Setting up a CI/CD pipeline using Vertex AI Pipelines to automate model deployment.", "isCorrect": false, "rationale": "This is a responsibility of the Guardian, who focuses on the operational aspects of deploying and maintaining the system." }
              ]
            },
            {
              "question": "How did the insurance company Hiscox leverage Vertex AI and BigQuery to achieve a significant business victory?",
              "hint": "Their success involved dramatically speeding up a core process that used to take several days.",
              "answerOptions": [
                { "text": "They built a chatbot that automated 30% of customer questions.", "isCorrect": false, "rationale": "Automating guest questions was the victory achieved by Six Flags, not Hiscox." },
                { "text": "They condensed 400-page financial reports into 3-page summaries.", "isCorrect": false, "rationale": "This use case belongs to Deutsche Bank, which used Gemini to accelerate internal research." },
                { "text": "They reduced the time to generate a quote for complex risks from 3 days to a few minutes.", "isCorrect": true, "rationale": "By creating an AI-enhanced underwriting model, they transformed a slow, manual analysis process into a near-instantaneous one." },
                { "text": "They increased user engagement with their AI assistant by 2.5 times.", "isCorrect": false, "rationale": "This outcome was achieved by Snap after integrating Gemini's multimodal capabilities into their 'My AI' feature." }
              ]
            },
            {
              "question": "What is the strategic value of the Vertex AI Model Garden for the guilds of the Agentverse?",
              "hint": "Think of it as a central place where builders can find the right tool or weapon for any job, regardless of who made it.",
              "answerOptions": [
                { "text": "It's a repository for storing and versioning custom-trained models only.", "isCorrect": false, "rationale": "While it can be used for custom models, its primary function is to provide access to a wide range of pre-existing foundation models." },
                { "text": "It provides a centralized place to discover, test, and deploy a wide variety of models from Google, partners, and open-source communities.", "isCorrect": true, "rationale": "This flexibility allows builders to select the best model for their specific task based on capability, cost, and customizability." },
                { "text": "It is an MLOps tool used exclusively for tracking experiment runs and model parameters.", "isCorrect": false, "rationale": "The tool for tracking experiments is Vertex AI Experiments, not the Model Garden." },
                { "text": "It is a black-box optimization service for automated hyperparameter tuning.", "isCorrect": false, "rationale": "The service for hyperparameter tuning is Vertex Vizier." }
              ]
            },
            {
              "question": "In the context of the generative era, what is the most critical role of the MLOps foundation of Vertex AI?",
              "hint": "The pace of innovation is a double-edged sword. How does the platform help Guardians manage this?",
              "answerOptions": [
                { "text": "To provide access to the most powerful models like Gemini 2.5.", "isCorrect": false, "rationale": "Access to models is provided through the Model Garden, but the MLOps foundation serves a different, operational purpose." },
                { "text": "To ensure that all models can be trained with 80% less code.", "isCorrect": false, "rationale": "This was a key claim at the platform's launch, but in the generative era, the MLOps value has shifted to address new challenges." },
                { "text": "To manage the rapid lifecycle of foundation models, providing stable aliases and clear retirement dates to prevent application breakage.", "isCorrect": true, "rationale": "This function transforms the rapid churn of models from an operational risk into a managed, strategic advantage for production applications." },
                { "text": "To allow developers to build applications using their preferred tools, such as Python or SQL.", "isCorrect": false, "rationale": "While the platform supports different tools for different personas, its core MLOps value is about managing the lifecycle, not just enabling development." }
              ]
            },
            {
              "question": "A Shadowblade is building an application that needs to analyze hours of video footage to identify key moments. Which model from the Gemini Arsenal is best suited for this task?",
              "hint": "This task requires a model that can handle a very large amount of information (video data) in a single request.",
              "answerOptions": [
                { "text": "Gemma 3 (27B)", "isCorrect": false, "rationale": "Gemma models are lightweight and designed for more specialized or resource-constrained tasks, not for processing massive, long-context multimodal inputs." },
                { "text": "Gemini 2.5 Flash-Lite", "isCorrect": false, "rationale": "Flash-Lite is optimized for high-volume, cost-sensitive tasks, but it may not be the best choice for the deep, long-context analysis required for hours of video." },
                { "text": "Gemini 2.5 Pro", "isCorrect": false, "rationale": "While a powerful model, its key feature is 'adaptive thinking' for complex reasoning. Another model is even better suited for extremely long inputs." },
                { "text": "Gemini 1.5 Pro", "isCorrect": true, "rationale": "This model's breakthrough 1-2 million token context window and native multimodality make it the ideal choice for ingesting and reasoning over very long inputs like extensive video footage." }
              ]
            }
          ]
        };

        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const nextBtn = document.getElementById('next-btn');

        const startScreen = document.getElementById('start-screen');
        const questionScreen = document.getElementById('question-screen');
        const resultsScreen = document.getElementById('results-screen');

        const questionText = document.getElementById('question-text');
        const hintText = document.getElementById('hint-text');
        const answerButtons = document.getElementById('answer-buttons');
        const progressText = document.getElementById('progress-text');
        const rationaleContainer = document.getElementById('rationale-container');
        
        const scoreText = document.getElementById('score-text');
        const scoreMessage = document.getElementById('score-message');

        let shuffledQuestions, currentQuestionIndex;
        let score = 0;

        function startQuiz() {
            startScreen.classList.add('hidden');
            resultsScreen.classList.add('hidden');
            questionScreen.classList.remove('hidden');
            
            shuffledQuestions = quizData.questions.sort(() => Math.random() - 0.5);
            currentQuestionIndex = 0;
            score = 0;
            setNextQuestion();
        }

        function setNextQuestion() {
            resetState();
            showQuestion(shuffledQuestions[currentQuestionIndex]);
        }

        function showQuestion(question) {
            progressText.innerText = `Question ${currentQuestionIndex + 1} of ${shuffledQuestions.length}`;
            questionText.innerText = question.question;
            hintText.innerText = `Hint: ${question.hint}`;
            
            // Shuffle answer options
            const shuffledOptions = [...question.answerOptions].sort(() => Math.random() - 0.5);

            shuffledOptions.forEach(answer => {
                const button = document.createElement('button');
                button.innerText = answer.text;
                button.classList.add('btn', 'option-btn', 'p-4', 'rounded-lg', 'text-left', 'w-full');
                button.dataset.correct = answer.isCorrect;
                button.dataset.rationale = answer.rationale;
                button.addEventListener('click', selectAnswer);
                answerButtons.appendChild(button);
            });
        }

        function resetState() {
            nextBtn.classList.add('hidden');
            rationaleContainer.classList.add('hidden');
            rationaleContainer.innerHTML = '';
            while (answerButtons.firstChild) {
                answerButtons.removeChild(answerButtons.firstChild);
            }
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === 'true';
            
            if (isCorrect) {
                score++;
            }

            Array.from(answerButtons.children).forEach(button => {
                setStatusClass(button, button.dataset.correct === 'true');
                button.disabled = true; // Disable all buttons after an answer is selected
            });
            
            // Show rationales
            Array.from(answerButtons.children).forEach(button => {
                const rationaleP = document.createElement('p');
                rationaleP.innerHTML = `<strong>${button.innerText}:</strong> ${button.dataset.rationale}`;
                rationaleP.classList.add('rationale', 'p-3', 'rounded-md', 'text-sm', 'mb-2', 'text-left');
                if (button.dataset.correct === 'true') {
                    rationaleP.classList.add('border-green-400');
                } else {
                     rationaleP.classList.add('border-red-400');
                }
                rationaleContainer.appendChild(rationaleP);
            });
            rationaleContainer.classList.remove('hidden');

            if (shuffledQuestions.length > currentQuestionIndex + 1) {
                nextBtn.classList.remove('hidden');
            } else {
                showResults();
            }
        }

        function setStatusClass(element, correct) {
            if (correct) {
                element.classList.add('correct');
            } else {
                element.classList.add('incorrect');
            }
        }

        function showResults() {
            questionScreen.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
            scoreText.innerText = `${score} / ${shuffledQuestions.length}`;
            
            let message = '';
            const percentage = (score / shuffledQuestions.length) * 100;
            if (percentage === 100) {
                message = "Perfect score! You are a true master of the Agentverse.";
            } else if (percentage >= 70) {
                message = "Excellent work! Your knowledge of the realm is formidable.";
            } else if (percentage >= 50) {
                message = "A good effort. Continue your studies to master the chronicles.";
            } else {
                message = "The chronicles are complex. Return to your studies and try again!";
            }
            scoreMessage.innerText = message;
        }

        startBtn.addEventListener('click', startQuiz);
        restartBtn.addEventListener('click', startQuiz);
        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            setNextQuestion();
        });

    </script>
</body>
</html>
